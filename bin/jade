#!/usr/bin/env node

/**
 * Module dependencies.
 */

var fs = require('fs')
  , resolve = require('path').resolve
  , basename = require('path').basename
  , jade;

try {
  jade = require('../lib/jade');
} catch (err) {
  jade = require('jade');
}

/**
 * Arguments.
 */

var args = process.argv.slice(2);

/**
 * Options javascript.
 */

var options = {};

/**
 * Destination dir.
 */

var dest;

/**
 * Watcher hash.
 */

var watchers;

/**
 * Directory to watch.
 */

var watchdir;

/**
 * Walk subdirectories
 */

var walk = false;

/**
 * Usage information.
 */

var usage = ''
  + '\n'
  + '  Usage: jade [options]\n'
  + '              [path ...]\n'
  + '              < in.jade > out.jade'
  + '  \n'
  + '  Options:\n'
  + '    -o, --options <str> JavaScript options object passed\n'
  + '    -h, --help          Output help information\n'
  + '    -w, --watch <dir>   Watch the jade files in <dir>\n'
  + '    --out <dir>         Output the compiled html to <dir>\n';
  + '\n';

// Parse arguments

var arg
  , files = [];
while (args.length) {
  arg = args.shift();
  switch (arg) {
    case '-h':
    case '--help':
      console.log(usage);
      process.exit(1);
      break;
    case '-o':
    case '--options':
      var str = args.shift();
      if (str) {
        options = eval('(' + str + ')');
      } else {
        console.error('-o, --options requires a string.');
        process.exit(1);
      }
      break;
    case '-w':
    case '--watch':
      watchdir = args.shift() || process.cwd();
      watchers = {};
      break;
    case '--out':
      dest = args.shift();
      break;
    case '-r':
      walk = true;
      break;
    default:
      files.push(arg);
  }
}

// Watching
if (watchers && !files.length) {
  console.log('Watching: ' + resolve(watchdir));
  fs.readdirSync(watchdir).map(function(filename) {
    return watchdir + '/' + filename;
  }).forEach(processFile);
// Render files
} else if (files.length) {
  files.forEach(function(file){
    jade.renderFile(file, options, function(err, html){
      if (err) throw err;
      writeFile(file, html);
    });
  });
// Stdio
} else {
  var buf = '';
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function(chunk){
    buf += chunk;
  }).on('end', function(){
    jade.render(buf, options, function(err, html){
      if (err) throw err;
      console.log(html);
    });
  }).resume();
}

/**
 * Process the given path, compiling the jade files found.
 * Walk the subdirectories if the -r flag was passed.
 */

function processFile(path) {
  fs.lstat(path, function(err, stat) {
    if (err) throw err;
    // Found jade file
    if (stat.isFile() && path.match(/\.jade$/)) {
      renderJade(path);
    // Found directory
    } else if (walk && stat.isDirectory()) {
      fs.readdir(path, function(err, files) {
        if (err) throw err;
        files.map(function(filename) {
          return path + '/' + filename;
        }).forEach(processFile);
      });
    }
  });
}

/**
 * Render jade
 */

function renderJade(jadefile) {
  jade.renderFile(jadefile, options, function(err, html) {
    if (err) throw err;
    writeFile(jadefile, html);
  });
}

/**
 * Write the html output to a file.
 *
 * If watching folder ./jades and the destination directory is ./public
 * a jade file in ./jades/person/index.jade will be written to 
 * ./public/person/index.html if the ./public/person folder exists.
 *
 * If not watching, the html output file is written to the root of the
 * destination directory, if specified.
 *
 * If no destination directory is specified, the output file is written
 * to the folder containing the jade file.
 */

function writeFile(src, html) {
  var path = src.replace('.jade', '.html');
  // watchdir and dest specified
  if (dest && watchdir) {
    path = path.replace(watchdir, dest);
  // dest specified, but we are not watching
  } else if (dest) {
    path = dest + '/' + basename(path);
  }
  fs.writeFile(path, html, function(err) {
    if (err) throw err;
    console.log('  \033[90mcompiled\033[0m %s', path);
    watch(src, renderJade);
  });
}

/**
 * Watch the given `file` and invoke `fn` when modified.
 */

function watch(file, fn) {
  // not watching
  if (!watchers) return;

  // already watched
  if (watchers[file]) return;

  // watch the file itself
  watchers[file] = true;
  console.log('  \033[90mwatching\033[0m %s', file);
  fs.watchFile(file, { interval: 50 }, function(curr, prev){
    if (curr.mtime > prev.mtime) fn(file);
  });
}
