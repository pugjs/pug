{"ts":1368138406122,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n  , fs = require('fs');\n\n/**\n * Library version.\n */\n\nexports.version = '0.30.0';\n\n/**\n * Expose self closing tags.\n */\n\nexports.selfClosing = require('./self-closing');\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction parse(str, options){\n  try {\n    // Parse\n    var parser = new Parser(str, options.filename, options);\n\n    // Compile\n    var compiler = new (options.compiler || Compiler)(parser.parse(), options)\n      , js = compiler.compile();\n\n    // Debug compiler\n    if (options.debug) {\n      console.error('\\nCompiled Function:\\n\\n\\033[90m%s\\033[0m', js.replace(/^/gm, '  '));\n    }\n\n    return ''\n      + 'var buf = [];\\n'\n      + (options.self\n        ? 'var self = locals || {};\\n' + js\n        : 'with (locals || {}) {\\n' + js + '\\n}\\n')\n      + 'return buf.join(\"\");';\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno);\n  }\n}\n\n/**\n * Strip any UTF-8 BOM off of the start of `str`, if it exists.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction stripBOM(str){\n  return 0xFEFF == str.charCodeAt(0)\n    ? str.substring(1)\n    : str;\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled template\n *   - `filename` used to improve errors when `compileDebug` is not `false`\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , filename = options.filename\n      ? JSON.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  str = stripBOM(String(str));\n\n  if (options.compileDebug !== false) {\n    fn = [\n        'jade.debug = [{ lineno: 1, filename: ' + filename + ' }];'\n      , 'try {'\n      , parse(str, options)\n      , '} catch (err) {'\n      , '  jade.rethrow(err, jade.debug[0].filename, jade.debug[0].lineno);'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parse(str, options);\n  }\n\n  if (options.client) return new Function('locals', fn)\n  fn = new Function('locals, jade', fn)\n  return function(locals){ return fn(locals, Object.create(runtime)) }\n};\n\n/**\n * Render the given `str` of jade and invoke\n * the callback `fn(err, str)`.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // swap args\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    return fn(new Error('the \"filename\" option is required for caching'));\n  }\n\n  try {\n    var path = options.filename;\n    var tmpl = options.cache\n      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n      : exports.compile(str, options);\n    fn(null, tmpl(options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Render a Jade file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  try {\n    options.filename = path;\n    var str = options.cache\n      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n    exports.render(str, options, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Express support.\n */\n\nexports.__express = exports.renderFile;\n"]],"start1":0,"start2":0,"length1":0,"length2":4700}]],"length":4700}
{"contributors":[],"silentsave":false,"ts":1368138422443,"patch":[[{"diffs":[[0,"er = new"],[1," (options.parser ||"],[0," Parser"],[1,")"],[0,"(str, op"]],"start1":1206,"start2":1206,"length1":23,"length2":43}]],"length":4720,"saved":false}
